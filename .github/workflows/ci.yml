name: CI + Helm Deploy

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

jobs:
  build-and-test:
    runs-on: ubuntu-latest
    env:
      NLU_APIKEY: ${{ secrets.NLU_APIKEY }}
      NLU_URL:    ${{ secrets.NLU_URL }}
      SERVICE_APIKEY: ${{ secrets.SERVICE_APIKEY }}
      DEV_MODE: ${{ github.ref == 'refs/heads/main' && 'false' || 'true' }}


    steps:
      # 1Ô∏è‚É£  Checkout code
      - uses: actions/checkout@v4

      # 2Ô∏è‚É£  Python toolchain
      - uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      # 3Ô∏è‚É£  Cache pip downloads
      - name: Cache pip
        uses: actions/cache@v4
        with:
          path: ~/.cache/pip
          key: ${{ runner.os }}-pip-${{ hashFiles('pyproject.toml') }}
          restore-keys: |
            ${{ runner.os }}-pip-

      # 4Ô∏è‚É£  Install deps (core + dev)
      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip setuptools wheel
          pip install -e ".[dev]"

      # 5Ô∏è‚É£  Restore cached pre-commit hook environments
      - name: Restore pre-commit envs
        uses: actions/cache@v4
        with:
          path: ~/.cache/pre-commit
          key:  ${{ runner.os }}-precommit-${{ hashFiles('.pre-commit-config.yaml') }}
          restore-keys: |
            ${{ runner.os }}-precommit-

      # 6Ô∏è‚É£  Lint & format checks (driven by .pre-commit-config.yaml)
      - name: Lint and format (pre-commit)
        run: pre-commit run --all-files --hook-stage manual

      # 7Ô∏è‚É£ Cache pytest‚Äôs own cache directory
      - name: Cache pytest cache
        uses: actions/cache@v4
        with:
          path: .pytest_cache
          key: ${{ runner.os }}-pytest-${{ hashFiles('**/pytest.ini') }}

      # 8Ô∏è‚É£  Tests + coverage
      - name: Prepare reports directory
        run: |
          mkdir -p reports/htmlcov

      - name: Run tests with coverage
        run: pytest -q

      # 9Ô∏è‚É£  Add coverage to repo
      - name: Upload coverage to Codecov
        uses: codecov/codecov-action@v3
        with:
          files: reports/coverage.xml
          flags: unittests

      # üîü  Build Docker image (optional artifact)
      - name: Build Docker image
        run: docker build . --tag notebook-to-prod:ci

      # 11Ô∏è‚É£  Check that secrets are passed (partial echo)
      - name: Check that secrets are passed (partial echo)
        run: |
          echo "NLU_APIKEY starts with: ${NLU_APIKEY:0:6}******"
          echo "NLU_URL base: $(echo $NLU_URL | cut -d/ -f3)"
        env:
          NLU_APIKEY: ${{ secrets.NLU_APIKEY }}
          NLU_URL: ${{ secrets.NLU_URL }}

      # 12Ô∏è‚É£  Run smoke test (mock NLU)
      - name: Run smoke test (mock NLU)
        if: github.ref != 'refs/heads/main'
        run: |
          # Start the container, capture its ID
          CONTAINER_ID=$(docker run -d \
            -p 8000:8000 \
            --env DEV_MODE=true \
            --env SERVICE_APIKEY="$SERVICE_APIKEY" \
            notebook-to-prod:ci)

          # Give it up to 10s to come online
          for i in $(seq 1 10); do
            if curl --fail http://localhost:8000/health; then
              break
            fi
            echo "Waiting for app‚Ä¶ ($i)"
            sleep 1
          done

          echo "ü™µ Container logs (ID=$CONTAINER_ID):"
          docker logs $CONTAINER_ID

          echo "üåê Hitting secured /run endpoint:"
          curl -H "X-Service-Key: $SERVICE_APIKEY" \
               -v http://localhost:8000/run/semantic_feature_extraction

          echo "üåê Listing processed files:"
          curl -H "X-Service-Key: $SERVICE_APIKEY" \
               http://localhost:8000/processed

          echo "üåê Downloading a processed artifact (CSV):"
          curl -H "X-Service-Key: $SERVICE_APIKEY" \
               http://localhost:8000/processed/concept_features.csv

          # Clean up now that we're done
          docker rm -f $CONTAINER_ID

      # üåü 13Ô∏è‚É£ Run smoke test (real Watson NLU)
      - name: Run smoke test (real Watson NLU)
        if: github.ref == 'refs/heads/main'
        run: |
          CONTAINER_ID=$(docker run -d \
            -p 8000:8000 \
            --env NLU_APIKEY="${{ secrets.NLU_APIKEY }}" \
            --env NLU_URL="${{ secrets.NLU_URL }}" \
            --env SERVICE_APIKEY="${{ secrets.SERVICE_APIKEY }}" \
            --env DEV_MODE=false \
            notebook-to-prod:ci)

          for i in $(seq 1 10); do
            if curl --fail http://localhost:8000/health; then
              break
            fi
            echo "Waiting for app‚Ä¶ ($i)"
            sleep 1
          done
          echo "ü™µ Container logs (ID=$CONTAINER_ID):"
          docker logs $CONTAINER_ID

          echo "üåê Hitting secured /run endpoint:"
          curl -H "X-Service-Key: $SERVICE_APIKEY" \
               -v http://localhost:8000/run/semantic_feature_extraction

          echo "üåê Downloading processed JSON:"
          curl -H "X-Service-Key: $SERVICE_APIKEY" \
               http://localhost:8000/processed/extracted_features.json

          docker rm -f $CONTAINER_ID

  # 14Ô∏è‚É£ Optional: Helm dry-run (feature branches only)
  helm-dry-run:
    needs: build-and-test
    if: github.ref != 'refs/heads/main'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Set up Helm
        uses: azure/setup-helm@v4
        with:
          version: v3.14.0
      - name: Helm template dry-run
        env:
          SERVICE_APIKEY: ${{ secrets.SERVICE_APIKEY }}
          NLU_APIKEY: ${{ secrets.NLU_APIKEY }}
          NLU_URL: ${{ secrets.NLU_URL }}
        run: |
          helm template nes ./notebook-execution-service \
            --set secrets.SERVICE_APIKEY=$SERVICE_APIKEY \
            --set secrets.NLU_APIKEY=$NLU_APIKEY \
            --set secrets.NLU_URL=$NLU_URL \
            --set persistence.enabled=true \
            --set persistence.mountPath=/app/data/processed \
            --dry-run > rendered.yaml
          echo "‚úÖ Helm chart rendered successfully"

  # 15Ô∏è‚É£ Deploy to Minikube (main only)
  deploy-to-minikube:
    needs: build-and-test
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    steps:
      - uses: actions/checkout@v4
      - name: Start Minikube
        uses: medyagh/setup-minikube@master

      - name: Build image in Minikube docker
        run: |
          eval $(minikube -p minikube docker-env)
          docker build -t notebook-to-prod:ci .

      - name: Helm upgrade/install
        run: |
          set -euo pipefail
          helm upgrade --install nes ./notebook-execution-service \
            --set image.repository=notebook-to-prod \
            --set image.tag=ci \
            --set image.pullPolicy=IfNotPresent \
            --set secrets.SERVICE_APIKEY=$SERVICE_APIKEY \
            --set secrets.NLU_APIKEY=$NLU_APIKEY \
            --set secrets.NLU_URL=$NLU_URL \
            --set ingress.enabled=false           \
            --set persistence.enabled=false       # keep CI simple
          kubectl rollout status deploy/nes-notebook-execution-service --timeout=120s
          kubectl get pods -o wide
        env:
          SERVICE_APIKEY: ${{ secrets.SERVICE_APIKEY }}
          NLU_APIKEY: ${{ secrets.NLU_APIKEY }}
          NLU_URL: ${{ secrets.NLU_URL }}

      - name: Debug on failure
        if: failure()
        run: |
          echo "---- PODS ----"
          kubectl get pods -o wide
          echo "---- DESCRIBE PODS ----"
          kubectl describe pods
          echo "---- EVENTS ----"
          kubectl get events --sort-by=.lastTimestamp | tail -n 100
          echo "---- LOGS ----"
          kubectl logs -l app.kubernetes.io/name=notebook-execution-service --all-containers --tail=200 || true
