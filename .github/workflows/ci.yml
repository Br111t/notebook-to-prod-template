name: CI + Helm Deploy

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

jobs:
  build-and-test:
    runs-on: ubuntu-latest
    env:
      NLU_APIKEY: ${{ secrets.NLU_APIKEY }}
      NLU_URL:    ${{ secrets.NLU_URL }}
      SERVICE_APIKEY: ${{ secrets.SERVICE_APIKEY }}
      DEV_MODE: ${{ github.ref == 'refs/heads/main' && 'false' || 'true' }}

    steps:
      # 1) Checkout code
      - uses: actions/checkout@v4

      # 2) Python toolchain
      - uses: actions/setup-python@v5
        with:
          python-version: "3.13"

      # 3) Cache pip downloads
      - name: Cache pip
        uses: actions/cache@v4
        with:
          path: ~/.cache/pip
          key: ${{ runner.os }}-pip-${{ hashFiles('pyproject.toml') }}
          restore-keys: |
            ${{ runner.os }}-pip-

      # 4) Install deps (core + dev)
      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip setuptools wheel
          pip install -e ".[dev]"

      # 5) Restore cached pre-commit hook environments
      - name: Restore pre-commit envs
        uses: actions/cache@v4
        with:
          path: ~/.cache/pre-commit
          key:  ${{ runner.os }}-precommit-${{ hashFiles('.pre-commit-config.yaml') }}
          restore-keys: |
            ${{ runner.os }}-precommit-

      # 6) Lint & format checks (driven by .pre-commit-config.yaml)
      - name: Lint and format (pre-commit)
        run: pre-commit run --all-files --hook-stage manual

      # 7) Cache pytest's own cache directory
      - name: Cache pytest cache
        uses: actions/cache@v4
        with:
          path: .pytest_cache
          key: ${{ runner.os }}-pytest-${{ hashFiles('**/pytest.ini') }}

      # 8) Tests + coverage
      - name: Prepare reports directory
        run: |
          mkdir -p reports/htmlcov

      - name: Run tests with coverage
        run: pytest -q

      - name: Critical coverage gate
        run: coverage report --rcfile=.coveragerc-critical

      # 9) Upload coverage to Codecov
      - name: Upload coverage to Codecov
        uses: codecov/codecov-action@v3
        with:
          files: reports/coverage.xml
          flags: unittests

      # 10) Build Docker image (optional artifact)
      - name: Build Docker image
        run: docker build . --tag notebook-to-prod:ci

      # 11) Check that secrets are passed (partial echo)
      - name: Check that secrets are passed (partial echo)
        run: |
          echo "NLU_APIKEY starts with: ${NLU_APIKEY:0:6}******"
          echo "NLU_URL base: $(echo $NLU_URL | cut -d/ -f3)"
        env:
          NLU_APIKEY: ${{ secrets.NLU_APIKEY }}
          NLU_URL: ${{ secrets.NLU_URL }}

      # 12) Run smoke test (mock NLU)
      - name: Run smoke test (mock NLU)
        if: github.ref != 'refs/heads/main'
        run: |
          # Start the container, capture its ID
          CONTAINER_ID=$(docker run -d \
            -p 8000:8000 \
            --env DEV_MODE=true \
            --env SERVICE_APIKEY="$SERVICE_APIKEY" \
            notebook-to-prod:ci)

          # Give it up to 10s to come online
          for i in $(seq 1 10); do
            if curl --fail http://localhost:8000/health; then
              break
            fi
            echo "Waiting for app ($i)"
            sleep 1
          done

          echo "Container logs (ID=$CONTAINER_ID):"
          docker logs $CONTAINER_ID

          echo "Hitting secured /run endpoint:"
          curl -H "X-SERVICE-Key: $SERVICE_APIKEY" \
               -v "http://localhost:8000/run?notebook=sfe.ipynb&fmt=trimmed"

          echo "Listing processed files:"
          curl -H "X-SERVICE-Key: $SERVICE_APIKEY" \
               http://localhost:8000/processed

          echo "Downloading a processed artifact (CSV):"
          curl -H "X-SERVICE-Key: $SERVICE_APIKEY" \
               http://localhost:8000/processed/concept_features.csv

          # Clean up now that we're done
          docker rm -f $CONTAINER_ID

      # 13) Run smoke test (real Watson NLU)
      - name: Run smoke test (real Watson NLU)
        if: github.ref == 'refs/heads/main'
        run: |
          CONTAINER_ID=$(docker run -d \
            -p 8000:8000 \
            --env NLU_APIKEY="${{ secrets.NLU_APIKEY }}" \
            --env NLU_URL="${{ secrets.NLU_URL }}" \
            --env SERVICE_APIKEY="${{ secrets.SERVICE_APIKEY }}" \
            --env DEV_MODE=false \
            notebook-to-prod:ci)

          for i in $(seq 1 10); do
            if curl --fail http://localhost:8000/health; then
              break
            fi
            echo "Waiting for app ($i)"
            sleep 1
          done
          echo "Container logs (ID=$CONTAINER_ID):"
          docker logs $CONTAINER_ID

          echo "Hitting secured /run endpoint:"
          curl -H "X-SERVICE-Key: $SERVICE_APIKEY" \
               -v "http://localhost:8000/run?notebook=sfe.ipynb&fmt=trimmed"

          echo "Downloading processed JSON:"
          curl -H "X-SERVICE-Key: $SERVICE_APIKEY" \
               http://localhost:8000/processed/extracted_features.json

          docker rm -f $CONTAINER_ID

  # 14) Optional: Helm dry-run (feature branches only)
  helm-dry-run:
    needs: build-and-test
    if: github.ref != 'refs/heads/main'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Set up Helm
        uses: azure/setup-helm@v4
        with:
          version: v3.14.0
      - name: Helm template dry-run
        env:
          SERVICE_APIKEY: ${{ secrets.SERVICE_APIKEY }}
          NLU_APIKEY: ${{ secrets.NLU_APIKEY }}
          NLU_URL: ${{ secrets.NLU_URL }}
        run: |
          helm template nes ./notebook-execution-service \
            --set secrets.SERVICE_APIKEY=$SERVICE_APIKEY \
            --set secrets.NLU_APIKEY=$NLU_APIKEY \
            --set secrets.NLU_URL=$NLU_URL \
            --set persistence.enabled=true \
            --set persistence.mountPath=/app/data/processed \
            --dry-run > rendered.yaml
          echo "Helm chart rendered successfully"

  # 15) Deploy to Minikube (main only)
  deploy-to-minikube:
    needs: build-and-test
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    steps:
      - uses: actions/checkout@v4
      - name: Start Minikube
        uses: medyagh/setup-minikube@master

      - name: Build image in Minikube docker
        run: |
          eval $(minikube -p minikube docker-env)
          docker build -t notebook-to-prod:ci .

      - name: Helm upgrade/install
        run: |
          set -euo pipefail
          helm upgrade --install nes ./notebook-execution-service \
            --set image.repository=notebook-to-prod \
            --set image.tag=ci \
            --set image.pullPolicy=IfNotPresent \
            --set secrets.SERVICE_APIKEY=$SERVICE_APIKEY \
            --set secrets.NLU_APIKEY=$NLU_APIKEY \
            --set secrets.NLU_URL=$NLU_URL \
            --set ingress.enabled=false           \
            --set persistence.enabled=false       # keep CI simple
          kubectl rollout status deploy/nes-notebook-execution-service --timeout=120s
          kubectl get pods -o wide
        env:
          SERVICE_APIKEY: ${{ secrets.SERVICE_APIKEY }}
          NLU_APIKEY: ${{ secrets.NLU_APIKEY }}
          NLU_URL: ${{ secrets.NLU_URL }}
